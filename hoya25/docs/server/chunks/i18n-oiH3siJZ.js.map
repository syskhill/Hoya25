{"version":3,"file":"i18n-oiH3siJZ.js","sources":["../../../node_modules/@inlang/paraglide-js/dist/adapter-utils/index.js","../../../.svelte-kit/adapter-node/chunks/i18n.js"],"sourcesContent":["function negotiateLanguagePreferences(accept, availableLanguageTags) {\n  accept ||= \"*\";\n  const acceptLanguageSpecs = parseAcceptLanguageHeader(accept);\n  const priorities = availableLanguageTags.map(\n    (languageTag, index) => getHighestLanguagePriority(languageTag, acceptLanguageSpecs, index)\n  );\n  return priorities.filter((prio) => prio.quality > 0).sort(bySpecificity).sort(byQuality).map((priority) => priority.languageTag);\n}\nfunction parseAcceptLanguageHeader(acceptLanguage) {\n  return acceptLanguage.split(\",\").map((dfn) => dfn.trim()).map((dfn, index) => parseLanguage(dfn, index)).filter((maybeSpec) => Boolean(maybeSpec));\n}\nfunction parseLanguage(languageTag, index) {\n  const LANGUAGE_REGEXP = /^\\s*([^\\s\\-;]+)(?:-([^\\s;]+))?\\s*(?:;(.*))?$/;\n  const match = LANGUAGE_REGEXP.exec(languageTag);\n  if (!match)\n    return void 0;\n  const [, prefix, suffix, qualityMatch] = match;\n  if (!prefix)\n    throw new Error(`Invalid language tag: ${languageTag}`);\n  const full = suffix ? `${prefix}-${suffix}` : prefix;\n  const quality = parseQuality(qualityMatch ?? \"\") ?? 1;\n  return {\n    prefix,\n    suffix,\n    quality,\n    index,\n    full\n  };\n}\nfunction parseQuality(qualityMatch) {\n  return qualityMatch.split(\";\").map((param) => param.split(\"=\")).filter((p) => p[0] == \"q\" && !!p[1]).map(([, value]) => parseFloat(value))[0];\n}\nfunction getHighestLanguagePriority(languageTag, acceptableLanguages, index) {\n  const priorities = acceptableLanguages.map((spec) => calculatePriority(languageTag, spec, index)).filter((prio) => Boolean(prio));\n  const highestPriority = priorities.sort(bySpecificity)[0] || {\n    languageTag,\n    index: 0,\n    order: -1,\n    quality: 0,\n    specificity: 0\n  };\n  return highestPriority;\n}\nfunction calculatePriority(languageTag, spec, index) {\n  const parsed = parseLanguage(languageTag, 0);\n  if (!parsed)\n    return void 0;\n  let specificity = 0;\n  if (spec.full.toLowerCase() === parsed.full.toLowerCase()) {\n    specificity = 4;\n  } else if (spec.prefix.toLowerCase() === parsed.full.toLowerCase()) {\n    specificity = 2;\n  } else if (spec.full.toLowerCase() === parsed.prefix.toLowerCase()) {\n    specificity = 1;\n  }\n  if (specificity === 0 && spec.full !== \"*\")\n    return void 0;\n  return {\n    languageTag,\n    index,\n    order: spec.index,\n    quality: spec.quality,\n    specificity\n  };\n}\nconst byQuality = (a, b) => b.quality - a.quality;\nconst bySpecificity = (a, b) => b.specificity - a.specificity || a.order - b.order || a.index - b.index;\nfunction detectLanguageFromPath({\n  path,\n  availableLanguageTags,\n  base\n}) {\n  base ??= \"\";\n  if (base === \"/\")\n    base = \"\";\n  if (!path.startsWith(base))\n    return void 0;\n  const pathWithoutBase = path.replace(base, \"\");\n  const maybeLang = pathWithoutBase.split(\"/\")[1];\n  if (!maybeLang)\n    return void 0;\n  return availableLanguageTags.map(lower).includes(lower(maybeLang)) ? maybeLang : void 0;\n}\nconst lower = (s) => s.toLowerCase();\nconst STATIC = 0;\nconst OPTIONAL = 1;\nconst REST = 2;\nconst REQUIRED = 4;\nconst PART_TYPE = 0;\nconst PART_CONTENT = 1;\nconst PART_MATCHED = 2;\nfunction sort_routes(routes) {\n  const get_parts = cached(split);\n  return routes.sort((route_a, route_b) => {\n    var _a, _b, _c, _d, _e, _f;\n    const segments_a = split_route_id(route_a).map(get_parts);\n    const segments_b = split_route_id(route_b).map(get_parts);\n    for (let i = 0; i < Math.max(segments_a.length, segments_b.length); i += 1) {\n      const segment_a = segments_a[i];\n      const segment_b = segments_b[i];\n      if (!segment_a)\n        return -1;\n      if (!segment_b)\n        return 1;\n      for (let j = 0; j < Math.max(segment_a.length, segment_b.length); j += 1) {\n        const a = segment_a[j];\n        const b = segment_b[j];\n        const dynamic = (a == null ? void 0 : a[PART_TYPE]) || (b == null ? void 0 : b[PART_TYPE]);\n        if (dynamic) {\n          if (!a)\n            return -1;\n          if (!b)\n            return 1;\n          const next_a = ((_a = segment_a[j + 1]) == null ? void 0 : _a[PART_CONTENT]) || ((_c = (_b = segments_a[i + 1]) == null ? void 0 : _b[0]) == null ? void 0 : _c[PART_CONTENT]);\n          const next_b = ((_d = segment_b[j + 1]) == null ? void 0 : _d[PART_CONTENT]) || ((_f = (_e = segments_b[i + 1]) == null ? void 0 : _e[0]) == null ? void 0 : _f[PART_CONTENT]);\n          const both_have_next = next_a && next_b;\n          const only_a_has_next = next_a && !next_b;\n          const only_b_has_next = !next_a && next_b;\n          if ((a[PART_TYPE] && b[PART_TYPE]) === REST) {\n            if (both_have_next)\n              continue;\n            if (only_a_has_next)\n              return -1;\n            if (only_b_has_next)\n              return 1;\n          }\n          if (a[PART_TYPE] === REST)\n            return only_a_has_next ? -1 : 1;\n          if (b[PART_TYPE] === REST)\n            return only_b_has_next ? 1 : -1;\n          if (a[PART_MATCHED] !== b[PART_MATCHED])\n            return (-1) ** +a[PART_MATCHED];\n          if (a[PART_TYPE] !== b[PART_TYPE]) {\n            return (-1) ** +(a[PART_TYPE] > b[PART_TYPE]);\n          }\n        } else if ((a == null ? void 0 : a[PART_CONTENT]) !== (b == null ? void 0 : b[PART_CONTENT])) {\n          return sort_static(a[PART_CONTENT], b[PART_CONTENT]);\n        }\n      }\n    }\n    return route_a < route_b ? 1 : -1;\n  });\n}\nfunction cached(fn) {\n  const cache = /* @__PURE__ */ new Map();\n  return (arg) => {\n    if (!cache.has(arg))\n      cache.set(arg, fn(arg));\n    return cache.get(arg);\n  };\n}\nfunction split(id) {\n  const parts = [];\n  let i = 0;\n  while (i <= id.length) {\n    const start = id.indexOf(\"[\", i);\n    const entirelyStatic = start === -1;\n    parts.push([STATIC, id.slice(i, entirelyStatic ? void 0 : start), false]);\n    if (entirelyStatic)\n      break;\n    const type = id[start + 1] === \"[\" ? OPTIONAL : id[start + 1] === \".\" ? REST : REQUIRED;\n    const endBrackets = type === OPTIONAL ? \"]]\" : \"]\";\n    const endBracketIdx = id.indexOf(endBrackets, start);\n    if (endBracketIdx === -1)\n      throw new Error(`Invalid route definition ${id}`);\n    const content = id.slice(start, i = endBracketIdx + endBrackets.length);\n    parts.push([type, content, content.includes(\"=\")]);\n  }\n  return parts;\n}\nconst split_route_id = (id) => id.replace(/\\[\\[[^\\]]+\\]\\](?!$)/g, \"\").split(\"/\").filter(Boolean);\nfunction sort_static(a, b) {\n  if (a === b)\n    return 0;\n  let idx = 0;\n  while (a[idx] === b[idx])\n    idx++;\n  return !a[idx] ? 1 : !b[idx] ? -1 : a[idx] < b[idx] ? -1 : 1;\n}\nconst param_pattern = /^(\\[)?(\\.\\.\\.)?(\\w+)(?:=(\\w+))?(\\])?$/;\nfunction parseRouteDefinition(id) {\n  const params = [];\n  const pattern = id === \"/\" ? /^\\/$/ : new RegExp(\n    `^${get_route_segments(id).map((segment) => {\n      const rest_match = /^\\[\\.\\.\\.(\\w+)(?:=(\\w+))?\\]$/.exec(segment);\n      if (rest_match) {\n        params.push({\n          name: rest_match[1],\n          matcher: rest_match[2],\n          optional: false,\n          rest: true,\n          chained: true\n        });\n        return \"(?:/(.*))?\";\n      }\n      const optional_match = /^\\[\\[(\\w+)(?:=(\\w+))?\\]\\]$/.exec(segment);\n      if (optional_match) {\n        params.push({\n          name: optional_match[1],\n          matcher: optional_match[2],\n          optional: true,\n          rest: false,\n          chained: true\n        });\n        return \"(?:/([^/]+))?\";\n      }\n      if (!segment) {\n        return;\n      }\n      const parts = segment.split(/\\[(.+?)\\](?!\\])/);\n      const result = parts.map((content, i) => {\n        if (i % 2) {\n          if (content.startsWith(\"x+\")) {\n            return escape(String.fromCharCode(parseInt(content.slice(2), 16)));\n          }\n          if (content.startsWith(\"u+\")) {\n            return escape(\n              String.fromCharCode(\n                ...content.slice(2).split(\"-\").map((code) => parseInt(code, 16))\n              )\n            );\n          }\n          const match = (\n            /** @type {RegExpExecArray} */\n            param_pattern.exec(content)\n          );\n          if (!match) {\n            throw new Error(`Invalid param: ${content}`);\n          }\n          const [, is_optional, is_rest, name, matcher] = match;\n          params.push({\n            name,\n            matcher,\n            optional: !!is_optional,\n            rest: !!is_rest,\n            chained: is_rest ? i === 1 && parts[0] === \"\" : false\n          });\n          return is_rest ? \"(.*?)\" : is_optional ? \"([^/]*)?\" : \"([^/]+?)\";\n        }\n        return escape(content);\n      }).join(\"\");\n      return \"/\" + result;\n    }).join(\"\")}/?$`\n  );\n  return { pattern, params };\n}\nfunction exec(match, params, matchers) {\n  const result = {};\n  const values = match.slice(1);\n  const values_needing_match = values.filter((v) => v !== void 0);\n  let buffered = 0;\n  for (const [i, param] of params.entries()) {\n    let value = values[i - buffered];\n    if (param.chained && param.rest && buffered) {\n      value = values.slice(i - buffered, i + 1).filter((s) => s).join(\"/\");\n      buffered = 0;\n    }\n    if (value === void 0) {\n      if (param.rest)\n        result[param.name] = \"\";\n      continue;\n    }\n    if (param.matcher && !matchers[param.matcher])\n      return void 0;\n    const matcher = matchers[param.matcher] ?? (() => true);\n    if (matcher(value)) {\n      result[param.name] = value;\n      const next_param = params[i + 1];\n      const next_value = values[i + 1];\n      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {\n        buffered = 0;\n      }\n      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {\n        buffered = 0;\n      }\n      continue;\n    }\n    if (param.optional && param.chained) {\n      buffered++;\n      continue;\n    }\n    return;\n  }\n  if (buffered)\n    return;\n  return result;\n}\nfunction escape(str) {\n  return str.normalize().replace(/[[\\]]/g, \"\\\\$&\").replace(/%/g, \"%25\").replace(/\\//g, \"%2[Ff]\").replace(/\\?/g, \"%3[Ff]\").replace(/#/g, \"%23\").replace(/[.*+?^${}()|\\\\]/g, \"\\\\$&\");\n}\nconst basic_param_pattern = /\\[(\\[)?(\\.\\.\\.)?(\\w+?)(?:=(\\w+))?\\]\\]?/g;\nfunction resolveRoute(id, params) {\n  return \"/\" + get_route_segments(id).map(\n    (segment) => segment.replace(basic_param_pattern, (_, optional, rest, name) => {\n      const param_value = params[name];\n      if (!param_value) {\n        if (optional || rest && param_value !== void 0)\n          return \"\";\n        else\n          throw new Error(`Missing parameter '${name}' in route ${id}`);\n      }\n      if (param_value[0] == \"/\" || param_value.endsWith(\"/\"))\n        throw new Error(`Parameter '${name}' in route ${id} cannot start or end with a slash`);\n      return param_value;\n    })\n  ).filter(Boolean).join(\"/\");\n}\nfunction bestMatch(canonicalPath, pathDefinitions, matchers) {\n  const sorted = sort_routes(pathDefinitions);\n  for (const pathDefinition of sorted) {\n    const route = parseRouteDefinition(pathDefinition);\n    const match = route.pattern.exec(removeTrailingSlash(canonicalPath));\n    if (!match)\n      continue;\n    const params = exec(match, route.params, matchers);\n    if (params)\n      return { params, id: pathDefinition };\n  }\n  return void 0;\n}\nconst removeTrailingSlash = (path) => path.endsWith(\"/\") ? path.slice(0, -1) : path;\nconst get_route_segments = (route) => route.slice(1).split(\"/\");\nfunction validatePathTranslations(pathTranslations, availableLanguageTags, matchers) {\n  const issues = [];\n  const expectedLanguages = new Set(availableLanguageTags);\n  const availableMatchers = new Set(Object.keys(matchers));\n  for (const path in pathTranslations) {\n    if (!isValidPath(path)) {\n      issues.push({\n        path,\n        message: \"Path must start with a slash.\"\n      });\n      continue;\n    }\n    const { params: expectedParams } = parseRouteDefinition(path);\n    const expectedMatchers = expectedParams.map((param) => param.matcher).filter(Boolean);\n    for (const matcher of expectedMatchers) {\n      if (!availableMatchers.has(matcher)) {\n        issues.push({\n          path,\n          message: `Matcher ${matcher} is used but not available. Did you forget to pass it to createI18n?`\n        });\n      }\n    }\n    const translations = pathTranslations[path];\n    if (!translations)\n      continue;\n    for (const [lang, translatedPath] of Object.entries(translations)) {\n      if (!isValidPath(translatedPath)) {\n        issues.push({\n          path,\n          message: `The translation for language ${lang} must start with a slash.`\n        });\n      }\n      const { params: actualParams } = parseRouteDefinition(translatedPath);\n      let paramsDontMatch = false;\n      for (const param of expectedParams) {\n        if (!actualParams.some((actualParam) => paramsAreEqual(param, actualParam))) {\n          paramsDontMatch = true;\n        }\n      }\n      if (expectedParams.length !== actualParams.length) {\n        paramsDontMatch = true;\n      }\n      if (paramsDontMatch) {\n        issues.push({\n          path,\n          message: `The translation for language ${lang} must have the same parameters as the canonical path.`\n        });\n      }\n    }\n    const translatedLanguages = new Set(Object.keys(translations));\n    if (!isSubset(expectedLanguages, translatedLanguages)) {\n      const missingLanguages = new Set(expectedLanguages);\n      for (const lang of translatedLanguages) {\n        missingLanguages.delete(lang);\n      }\n      issues.push({\n        path,\n        message: `The following languages are missing translations: ${[...missingLanguages].join(\n          \", \"\n        )}`\n      });\n    }\n  }\n  return issues;\n}\nfunction paramsAreEqual(param1, param2) {\n  return param1.chained == param2.chained && param1.matcher == param2.matcher && param1.name == param2.name && param1.optional == param2.optional && param1.rest == param2.rest;\n}\nfunction isValidPath(maybePath) {\n  return maybePath.startsWith(\"/\");\n}\nfunction isSubset(a, b) {\n  for (const value of a) {\n    if (!b.has(value))\n      return false;\n  }\n  return true;\n}\nfunction prettyPrintPathDefinitionIssues(issues) {\n  return issues.map((issue) => `${issue.path}: ${issue.message}`).join(\"\\n\");\n}\nconst resolveUserPathDefinitions = (userTranslations, availableLanguageTags) => Object.fromEntries(\n  Object.entries(userTranslations).map(([path, translation]) => [\n    path,\n    typeof translation === \"object\" ? translation : fromMessage(translation, availableLanguageTags)\n  ])\n);\nconst fromMessage = (message, availableLanguageTags) => Object.fromEntries(\n  availableLanguageTags.map((languageTag) => [languageTag, message({}, { languageTag })])\n);\nexport {\n  bestMatch,\n  detectLanguageFromPath,\n  negotiateLanguagePreferences,\n  parseRouteDefinition,\n  prettyPrintPathDefinitionIssues,\n  resolveRoute,\n  resolveUserPathDefinitions,\n  validatePathTranslations\n};\n","import \"clsx\";\nimport \"./client2.js\";\nimport { negotiateLanguagePreferences, bestMatch, resolveRoute } from \"@inlang/paraglide-js/internal/adapter-utils\";\nimport { b as base } from \"./paths.js\";\nimport { L as LANG_COOKIE_NAME } from \"./constants.js\";\nimport { g as getContext } from \"./index2.js\";\nimport { k as get } from \"./exports.js\";\nlet _onSetLanguageTag;\nconst sourceLanguageTag = \"en\";\nconst availableLanguageTags = (\n  /** @type {const} */\n  [\"en\"]\n);\nlet languageTag = () => sourceLanguageTag;\nconst setLanguageTag = (tag) => {\n  if (typeof tag === \"function\") {\n    languageTag = enforceLanguageTag(tag);\n  } else {\n    languageTag = enforceLanguageTag(() => tag);\n  }\n  if (_onSetLanguageTag !== void 0) {\n    _onSetLanguageTag(languageTag());\n  }\n};\nfunction enforceLanguageTag(unsafeLanguageTag) {\n  return () => {\n    const tag = unsafeLanguageTag();\n    if (!isAvailableLanguageTag(tag)) {\n      throw new Error(`languageTag() didn't return a valid language tag. Check your setLanguageTag call`);\n    }\n    return tag;\n  };\n}\nconst onSetLanguageTag = (fn) => {\n  _onSetLanguageTag = fn;\n};\nfunction isAvailableLanguageTag(thing) {\n  return availableLanguageTags.includes(thing);\n}\nconst runtime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  availableLanguageTags,\n  isAvailableLanguageTag,\n  get languageTag() {\n    return languageTag;\n  },\n  onSetLanguageTag,\n  setLanguageTag,\n  sourceLanguageTag\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst getStores = () => {\n  const stores$1 = getContext(\"__svelte__\");\n  return {\n    /** @type {typeof page} */\n    page: {\n      subscribe: stores$1.page.subscribe\n    },\n    /** @type {typeof navigating} */\n    navigating: {\n      subscribe: stores$1.navigating.subscribe\n    },\n    /** @type {typeof updated} */\n    updated: stores$1.updated\n  };\n};\nconst page = {\n  subscribe(fn) {\n    const store = getStores().page;\n    return store.subscribe(fn);\n  }\n};\nfunction normaliseBase$1(baseValue, currentUrl) {\n  if (baseValue === \"\")\n    return \"\";\n  const absoluteBase = new URL(baseValue, currentUrl).pathname;\n  return absoluteBase.endsWith(\"/\") ? absoluteBase.slice(0, -1) : absoluteBase;\n}\nfunction parseRoute(fullPath, normalizedBase) {\n  const decodedPath = safeDecode(fullPath);\n  const pathWithoutBase = removeBase(decodedPath, normalizedBase);\n  const [path, dataSuffix] = removeDataSuffix(pathWithoutBase);\n  return [path, dataSuffix];\n}\nconst serializeRoute = (path, normalizedBase, dataSuffix) => [normalizedBase, path, dataSuffix ?? \"\"].filter((s) => s !== \"/\").join(\"\") || \"/\";\nfunction removeBase(absolutePath, normalizedBase) {\n  const withoutBase = absolutePath.replace(normalizedBase, \"\");\n  return withoutBase.startsWith(\"/\") ? withoutBase : `/${withoutBase}`;\n}\nfunction removeDataSuffix(absolutePath) {\n  const KNOWN_SUFFIXES = [\"/.html__data.json\", \"/__data.json\"];\n  const dataSuffix = KNOWN_SUFFIXES.find((suffix) => absolutePath.endsWith(suffix));\n  if (dataSuffix) {\n    return [absolutePath.slice(0, -dataSuffix.length) || \"/\", dataSuffix];\n  } else {\n    return [absolutePath, void 0];\n  }\n}\nfunction safeDecode(maybeEncoded) {\n  try {\n    return decodeURI(maybeEncoded);\n  } catch {\n    return maybeEncoded;\n  }\n}\nfunction getHrefBetween(from, to) {\n  if (from.protocol !== to.protocol) {\n    return to.href;\n  }\n  if (to.password || to.username) {\n    const credentials = [to.username, to.password].filter(Boolean).join(\":\");\n    return \"//\" + credentials + \"@\" + to.host + to.pathname + to.search + to.hash;\n  }\n  if (from.host !== to.host) {\n    return \"//\" + to.host + to.pathname + to.search + to.hash;\n  }\n  return to.pathname + to.search + to.hash;\n}\nclass ALSContext {\n  ctx;\n  constructor(ALS) {\n    this.ctx = new ALS();\n  }\n  get() {\n    return this.ctx.getStore();\n  }\n  async callAsync(val, cb) {\n    return await this.ctx.run(val, cb);\n  }\n}\nclass GlobalContext {\n  value = void 0;\n  get() {\n    return this.value;\n  }\n  async callAsync(val, cb) {\n    this.value = val;\n    return await cb();\n  }\n}\nconst VARY_HEADER = [\"cookie\", \"accept-language\"].join(\", \");\nconst createHandle = (strategy, i18n2, options) => {\n  let languageContext = void 0;\n  function initializeLanguageContext(AsyncLocalStorage) {\n    languageContext = AsyncLocalStorage ? new ALSContext(AsyncLocalStorage) : new GlobalContext();\n    i18n2.runtime.setLanguageTag(() => {\n      if (!languageContext)\n        throw new Error(\"languageContext not initialized - This should never happen, please file an issue\");\n      const val = languageContext.get();\n      return i18n2.runtime.isAvailableLanguageTag(val) ? val : i18n2.defaultLanguageTag;\n    });\n  }\n  const langPlaceholder = options.langPlaceholder ?? \"%paraglide.lang%\";\n  const dirPlaceholder = options.textDirectionPlaceholder ?? \"%paraglide.textDirection%\";\n  return async ({ resolve, event }) => {\n    if (!languageContext) {\n      const als = options.disableAsyncLocalStorage ? void 0 : (await import(\"node:async_hooks\")).AsyncLocalStorage;\n      initializeLanguageContext(als);\n    }\n    const [localisedPath, suffix] = parseRoute(event.url.pathname, base);\n    const langFromUrl = strategy.getLanguageFromLocalisedPath(localisedPath);\n    const langCookie = event.cookies.get(LANG_COOKIE_NAME);\n    const cookieLang = i18n2.runtime.isAvailableLanguageTag(langCookie) ? langCookie : void 0;\n    const negotiatedLanguagePreferences = negotiateLanguagePreferences(event.request.headers.get(\"accept-language\"), i18n2.runtime.availableLanguageTags);\n    const negotiatedLanguage = negotiatedLanguagePreferences[0];\n    const lang = langFromUrl ?? cookieLang ?? negotiatedLanguage ?? i18n2.defaultLanguageTag;\n    if (lang !== langFromUrl && !i18n2.exclude(localisedPath)) {\n      const localisedPathname = strategy.getLocalisedPath(localisedPath, lang);\n      const fullPath = serializeRoute(localisedPathname, base, suffix);\n      const to = new URL(event.url);\n      to.pathname = fullPath;\n      const href = getHrefBetween(event.url, to);\n      return new Response(void 0, {\n        status: 302,\n        headers: {\n          Location: href,\n          Vary: VARY_HEADER\n        }\n      });\n    }\n    if (lang !== cookieLang && !i18n2.exclude(event.url.pathname)) {\n      event.cookies.set(LANG_COOKIE_NAME, lang, {\n        maxAge: 31557600,\n        sameSite: \"lax\",\n        path: base || \"/\",\n        httpOnly: false\n      });\n    }\n    const textDirection = i18n2.textDirection[lang] ?? \"ltr\";\n    const paraglideLocals = {\n      lang,\n      textDirection\n    };\n    event.locals.paraglide = paraglideLocals;\n    if (!languageContext)\n      throw new Error(\"languageContext not initialized - This should never happen, please file an issue\");\n    return languageContext.callAsync(paraglideLocals.lang, async () => {\n      return await resolve(event, {\n        transformPageChunk({ html, done }) {\n          if (!done)\n            return html;\n          return html.replace(langPlaceholder, lang).replace(dirPlaceholder, textDirection);\n        }\n      });\n    });\n  };\n};\nconst createReroute = (strategy) => {\n  return ({ url }) => {\n    try {\n      const [localisedPath, dataSuffix] = parseRoute(url.pathname, base);\n      const lang = strategy.getLanguageFromLocalisedPath(localisedPath);\n      if (!lang)\n        return url.pathname;\n      const canonicalPath = strategy.getCanonicalPath(localisedPath, lang);\n      return serializeRoute(canonicalPath, base, dataSuffix);\n    } catch (e) {\n      return url.pathname;\n    }\n  };\n};\nfunction normalize(path) {\n  return `/${path.split(\"/\").filter(Boolean).join(\"/\")}`;\n}\nfunction createExclude(excludeConfig) {\n  const checks = excludeConfig.map((exclude) => typeof exclude === \"string\" ? (path) => path === exclude : (path) => exclude.test(path));\n  return (path) => checks.some((check) => check(normalize(path)));\n}\nconst RTL = \"rtl\";\nconst LTR = \"ltr\";\nfunction guessTextDir(lang) {\n  try {\n    const locale = new Intl.Locale(lang);\n    if (\"textInfo\" in locale) {\n      return locale.textInfo.direction === RTL ? RTL : LTR;\n    }\n    return locale.getTextInfo().direction === RTL ? RTL : LTR;\n  } catch (e) {\n    return LTR;\n  }\n}\nfunction guessTextDirMap(langs) {\n  const entries = langs.map((lang) => [lang, guessTextDir(lang)]);\n  return Object.fromEntries(entries);\n}\nfunction PrefixStrategy(availableLanguageTags2, defaultLanguageTag, translations, matchers, prefixDefaultLanguage) {\n  function getLanguageFromLocalisedPath(localisedPath) {\n    const segments = localisedPath.split(\"/\");\n    const maybeLang = segments[1];\n    if (availableLanguageTags2.includes(maybeLang) && (prefixDefaultLanguage === \"always\" || maybeLang !== defaultLanguageTag)) {\n      return maybeLang;\n    }\n    if (prefixDefaultLanguage === \"never\")\n      return defaultLanguageTag;\n    else\n      return void 0;\n  }\n  function getLocalisedPath(canonicalPath, languageTag2) {\n    const trailingSlash = canonicalPath.endsWith(\"/\") && canonicalPath !== \"/\";\n    canonicalPath = trailingSlash ? canonicalPath.slice(0, -1) : canonicalPath;\n    let translatedPath = turnIntoTranslatedPath(canonicalPath, languageTag2, translations, matchers);\n    if (trailingSlash) {\n      translatedPath += \"/\";\n    }\n    if (prefixDefaultLanguage === \"always\" || languageTag2 !== defaultLanguageTag) {\n      translatedPath = `/${languageTag2}${translatedPath}`;\n    }\n    return translatedPath;\n  }\n  function getCanonicalPath(localisedPath, languageTag2) {\n    const trailingSlahsBefore = localisedPath.endsWith(\"/\") && localisedPath !== \"/\";\n    if (prefixDefaultLanguage === \"always\" || languageTag2 !== defaultLanguageTag) {\n      localisedPath = localisedPath.replace(`/${languageTag2}`, \"\") || \"/\";\n    }\n    const trailingSlash = trailingSlahsBefore;\n    localisedPath = trailingSlash ? localisedPath.slice(0, -1) : localisedPath;\n    let canonicalPath = turnIntoCanonicalPath(localisedPath, languageTag2, translations, matchers);\n    if (trailingSlash) {\n      canonicalPath += \"/\";\n    }\n    return canonicalPath;\n  }\n  return {\n    getLanguageFromLocalisedPath,\n    getLocalisedPath,\n    getCanonicalPath\n  };\n}\nfunction turnIntoCanonicalPath(translatedPath, lang, translations, matchers) {\n  for (const [canonicalPathDefinition, translationsForPath] of Object.entries(translations)) {\n    if (!(lang in translationsForPath))\n      continue;\n    const translatedPathDefinition = translationsForPath[lang];\n    if (!translatedPathDefinition)\n      continue;\n    const match = bestMatch(translatedPath, [translatedPathDefinition], matchers);\n    if (!match)\n      continue;\n    return resolveRoute(canonicalPathDefinition, match.params);\n  }\n  return translatedPath;\n}\nfunction turnIntoTranslatedPath(canonicalPath, lang, translations, matchers) {\n  const match = bestMatch(canonicalPath, Object.keys(translations), matchers);\n  if (!match)\n    return canonicalPath;\n  const translationsForPath = translations[match.id];\n  if (!translationsForPath)\n    return canonicalPath;\n  const translatedPath = translationsForPath[lang];\n  if (!translatedPath)\n    return canonicalPath;\n  return resolveRoute(translatedPath, match.params);\n}\nfunction createI18n(runtime2, options) {\n  const translations = {};\n  const excludeConfig = [];\n  const defaultLanguageTag = runtime2.sourceLanguageTag;\n  const config = {\n    defaultLanguageTag,\n    runtime: runtime2,\n    translations,\n    matchers: {},\n    exclude: createExclude(excludeConfig),\n    prefixDefaultLanguage: \"never\",\n    textDirection: guessTextDirMap(runtime2.availableLanguageTags),\n    seo: {\n      noAlternateLinks: false\n    }\n  };\n  const strategy = PrefixStrategy(runtime2.availableLanguageTags, defaultLanguageTag, config.translations, config.matchers, config.prefixDefaultLanguage);\n  Object.freeze(translations);\n  Object.freeze(config);\n  return {\n    /**\n     * The configuration that was used to create this i18n instance.\n     */\n    config,\n    /**\n     * The routing strategy that's being used.\n     *\n     * @private Not part of the public API, may change in non-major versions\n     */\n    strategy,\n    /**\n     * Returns a `reroute` hook that applies the path translations to the paths.\n     * Register it in your `src/hooks.js` file to enable path translations.\n     *\n     * @example\n     * ```ts\n     * // src/hooks.js\n     * import { i18n } from \"../lib/i18n.js\"\n     * export const reroute = i18n.reroute()\n     * ```\n     */\n    reroute: () => createReroute(strategy),\n    /**\n     * Returns a `handle` hook that set's the correct `lang` attribute\n     * on the `html` element\n     *\n     * SERVER ONLY\n     */\n    handle: (options2 = {}) => {\n      return createHandle(strategy, config, options2);\n    },\n    /**\n     * Takes in a URL and returns the language that should be used for it.\n     *\n     * @param url\n     * @returns\n     */\n    getLanguageFromUrl(url) {\n      const normalizedBase = normaliseBase(base);\n      const [localizedPath] = parseRoute(url.pathname, normalizedBase);\n      if (config.exclude(localizedPath))\n        return config.defaultLanguageTag;\n      return strategy.getLanguageFromLocalisedPath(localizedPath) || config.defaultLanguageTag;\n    },\n    /**\n     * Takes in a route and returns a translated version of it.\n     * This is useful for use in `goto` statements and `redirect` calls.\n     *\n     * The oposite of `i18n.route()`.\n     *\n     * @param canonicalPath The path to translate (eg _/base/about_)\n     * @param lang The language to translate to - Defaults to the current language\n     * @returns The translated path (eg _/base/de/ueber-uns_)\n     *\n     * @example\n     * ```ts\n     * redirect(i18n.resolveRoute(\"/base/about\", \"de\"))\n     * ```\n     */\n    resolveRoute(path, lang = void 0) {\n      if (config.exclude(path))\n        return path;\n      const normalizedBase = normaliseBase(base);\n      const [canonicalPath, dataSuffix] = parseRoute(path, normalizedBase);\n      lang = lang ?? runtime2.languageTag();\n      if (!path.startsWith(normalizedBase))\n        return path;\n      const localisedPath = strategy.getLocalisedPath(canonicalPath, lang);\n      return serializeRoute(localisedPath, normalizedBase, dataSuffix);\n    },\n    /**\n     * Takes in a path in one language and returns it's canonical version.\n     * The oposite of `i18n.resolveRoute()`.\n     * This is useful for use in:\n     * - Language Switchers\n     * - Navigation\n     *\n     * @param targetedPathSource The path to translate (eg _/base/de/ueber-uns_)\n     * @returns The canonical version path (eg _/base/about_)\n     *\n     * @example\n     * ```ts\n     * <a\n     *   href={i18n.route($page.url.pathname)}\n     *   hreflang=\"en\"\n     * >\n     * ```\n     */\n    route(translatedPath) {\n      const normalizedBase = normaliseBase(base);\n      const [localisedPath, dataSuffix] = parseRoute(translatedPath, normalizedBase);\n      const lang = strategy.getLanguageFromLocalisedPath(localisedPath);\n      const languageTag2 = lang || config.defaultLanguageTag;\n      const canonicalPath = strategy.getCanonicalPath(localisedPath, languageTag2);\n      return serializeRoute(canonicalPath, normalizedBase, dataSuffix);\n    }\n  };\n}\nfunction normaliseBase(base2) {\n  if (base2 === \"\")\n    return \"\";\n  if (base2.startsWith(\"/\"))\n    return base2;\n  return normaliseBase$1(base2, new URL(get(page).url));\n}\nconst i18n = createI18n(runtime);\nexport {\n  i18n as i,\n  languageTag as l\n};\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}